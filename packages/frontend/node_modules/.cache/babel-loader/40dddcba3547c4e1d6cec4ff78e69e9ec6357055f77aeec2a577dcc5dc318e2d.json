{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useState } from 'react';\nimport { CATCHER_SPEED, DEFAULT_CATCHER, DROPS_LIST, DROPS_SCORE_MAP, DROP_SIZE, DROP_SPEED } from './constants';\nimport { checkColliding } from './helper';\nexport const useGame = (fieldRef, requestRef) => {\n  _s();\n  const [drops, setDrops] = useState([]);\n  const [catcher, setCatcher] = useState(DEFAULT_CATCHER);\n  const [score, setScore] = useState(0);\n  const [cursorX, setCursorX] = useState(0);\n  const createDrops = useCallback(() => {\n    if (!fieldRef.current) {\n      return {};\n    }\n    const image = DROPS_LIST[Math.floor(Math.random() * DROPS_LIST.length)];\n    const x = Math.floor(Math.random() * 100) * fieldRef.current.offsetWidth / 100;\n    const score = DROPS_SCORE_MAP[image];\n    return {\n      image,\n      x,\n      y: 0,\n      size: DROP_SIZE,\n      score\n    };\n  }, [fieldRef]);\n  const spawnDrops = useCallback(() => {\n    console.log('spawnDrops');\n    setDrops(oldDrops => [...oldDrops, createDrops()]);\n  }, [createDrops]);\n  const updateDropY = useCallback(() => {\n    setDrops(oldDrops => {\n      const newDrops = [];\n      oldDrops.forEach(drop => {\n        const newY = drop.y + DROP_SPEED / 60;\n        const isColliding = checkColliding(drop, catcher);\n        if (isColliding) {\n          setScore(score + drop.score);\n        }\n        if (fieldRef.current && newY <= fieldRef.current.offsetHeight && !isColliding) {\n          newDrops.push({\n            ...drop,\n            y: newY\n          });\n        }\n      });\n      return newDrops;\n    });\n  }, [catcher, fieldRef, score]);\n  const onCursorMove = event => {\n    if (!fieldRef.current) {\n      return;\n    }\n    setCursorX(event.clientX - (fieldRef.current.offsetLeft - fieldRef.current.offsetWidth / 2));\n  };\n  const updateCatcher = useCallback(() => {\n    setCatcher(oldCatcher => {\n      const detlaX = cursorX - oldCatcher.x;\n      let newCatcherX;\n      if (5 > detlaX && detlaX > -5) {\n        newCatcherX = oldCatcher.x;\n      } else if (detlaX > 1) {\n        newCatcherX = oldCatcher.x + CATCHER_SPEED / 60;\n      } else {\n        newCatcherX = oldCatcher.x - CATCHER_SPEED / 60;\n      }\n      return {\n        ...oldCatcher,\n        x: newCatcherX\n      };\n    });\n  }, [cursorX]);\n  const advanceStep = useCallback(() => {\n    updateCatcher();\n    updateDropY();\n    requestRef.current = requestAnimationFrame(advanceStep);\n  }, [requestRef, updateCatcher, updateDropY]);\n\n  // TODO: delete unused output\n  return {\n    drops,\n    spawnDrops,\n    catcher,\n    score,\n    onCursorMove,\n    advanceStep\n  };\n};\n_s(useGame, \"DPMImsCs3dmfOOukZcLVSJLKIXk=\");","map":{"version":3,"names":["useCallback","useState","CATCHER_SPEED","DEFAULT_CATCHER","DROPS_LIST","DROPS_SCORE_MAP","DROP_SIZE","DROP_SPEED","checkColliding","useGame","fieldRef","requestRef","drops","setDrops","catcher","setCatcher","score","setScore","cursorX","setCursorX","createDrops","current","image","Math","floor","random","length","x","offsetWidth","y","size","spawnDrops","console","log","oldDrops","updateDropY","newDrops","forEach","drop","newY","isColliding","offsetHeight","push","onCursorMove","event","clientX","offsetLeft","updateCatcher","oldCatcher","detlaX","newCatcherX","advanceStep","requestAnimationFrame"],"sources":["C:/workspace/drop-catching-game/packages/frontend/src/features/game/useGame.ts"],"sourcesContent":["import {\r\n    MouseEvent,\r\n    MutableRefObject,\r\n    RefObject,\r\n    useCallback,\r\n    useState,\r\n} from 'react'\r\nimport {\r\n    CATCHER_SPEED,\r\n    DEFAULT_CATCHER,\r\n    DROPS_LIST,\r\n    DROPS_SCORE_MAP,\r\n    DROP_SIZE,\r\n    DROP_SPEED,\r\n} from './constants'\r\nimport { ICatcher, IDrop } from './types'\r\nimport { checkColliding } from './helper'\r\n\r\nexport const useGame = (\r\n    fieldRef: RefObject<HTMLDivElement>,\r\n    requestRef: MutableRefObject<number>\r\n) => {\r\n    const [drops, setDrops] = useState<IDrop[]>([])\r\n    const [catcher, setCatcher] = useState<ICatcher>(DEFAULT_CATCHER)\r\n    const [score, setScore] = useState(0)\r\n    const [cursorX, setCursorX] = useState(0)\r\n\r\n    const createDrops = useCallback(() => {\r\n        if (!fieldRef.current) {\r\n            return {} as IDrop\r\n        }\r\n        const image = DROPS_LIST[Math.floor(Math.random() * DROPS_LIST.length)]\r\n        const x =\r\n            (Math.floor(Math.random() * 100) * fieldRef.current.offsetWidth) /\r\n            100\r\n        const score = DROPS_SCORE_MAP[image]\r\n\r\n        return {\r\n            image,\r\n            x,\r\n            y: 0,\r\n            size: DROP_SIZE,\r\n            score,\r\n        }\r\n    }, [fieldRef])\r\n\r\n    const spawnDrops = useCallback(() => {\r\n        console.log('spawnDrops')\r\n        setDrops((oldDrops) => [...oldDrops, createDrops()])\r\n    }, [createDrops])\r\n\r\n    const updateDropY = useCallback(() => {\r\n        setDrops((oldDrops) => {\r\n            const newDrops: IDrop[] = []\r\n            oldDrops.forEach((drop) => {\r\n                const newY = drop.y + DROP_SPEED / 60\r\n                const isColliding = checkColliding(drop, catcher)\r\n                if (isColliding) {\r\n                    setScore(score + drop.score)\r\n                }\r\n                if (\r\n                    fieldRef.current &&\r\n                    newY <= fieldRef.current.offsetHeight &&\r\n                    !isColliding\r\n                ) {\r\n                    newDrops.push({\r\n                        ...drop,\r\n                        y: newY,\r\n                    })\r\n                }\r\n            })\r\n            return newDrops\r\n        })\r\n    }, [catcher, fieldRef, score])\r\n\r\n    const onCursorMove = (event: MouseEvent) => {\r\n        if (!fieldRef.current) {\r\n            return\r\n        }\r\n        setCursorX(\r\n            event.clientX -\r\n                (fieldRef.current.offsetLeft - fieldRef.current.offsetWidth / 2)\r\n        )\r\n    }\r\n\r\n    const updateCatcher = useCallback(() => {\r\n        setCatcher((oldCatcher) => {\r\n            const detlaX = cursorX - oldCatcher.x\r\n            let newCatcherX\r\n            if (5 > detlaX && detlaX > -5) {\r\n                newCatcherX = oldCatcher.x\r\n            } else if (detlaX > 1) {\r\n                newCatcherX = oldCatcher.x + CATCHER_SPEED / 60\r\n            } else {\r\n                newCatcherX = oldCatcher.x - CATCHER_SPEED / 60\r\n            }\r\n            return { ...oldCatcher, x: newCatcherX }\r\n        })\r\n    }, [cursorX])\r\n\r\n    const advanceStep = useCallback(() => {\r\n        updateCatcher()\r\n        updateDropY()\r\n        requestRef.current = requestAnimationFrame(advanceStep)\r\n    }, [requestRef, updateCatcher, updateDropY])\r\n\r\n    // TODO: delete unused output\r\n    return {\r\n        drops,\r\n        spawnDrops,\r\n        catcher,\r\n        score,\r\n        onCursorMove,\r\n        advanceStep,\r\n    }\r\n}\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}